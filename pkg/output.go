package pkg

import (
	"fmt"
	"path"
	"regexp"
	"sort"
	"strings"
)

type importPath struct {
	alias string
	path  string
}
type outputer struct {
	data    []string
	dupFunc map[string]struct{}
	outFunc []string
	imports map[string]importPath

	targetDir string
}

func newOutPuter() *outputer {
	return &outputer{
		data:    []string{},
		dupFunc: map[string]struct{}{},
		imports: map[string]importPath{},
		outFunc: []string{},
	}
}

func (o *outputer) addFuncCheckIfNeedGenerated(fn string) bool {
	_, exists := o.dupFunc[fn]
	if exists {
		return false
	}
	o.dupFunc[fn] = struct{}{}
	return true
}

func (o *outputer) appendImport(alias, path string) {
	if alias == "" && path == "" {
		return
	}

	o.imports[alias+path] = importPath{alias, path}
}

func (o *outputer) write(text string) {
	re := regexp.MustCompile(`(?m)^\s*$\n`)
	text = re.ReplaceAllString(text, "")
	o.data = append(o.data, text)
}

func (o *outputer) writeFunc(text string) {
	re := regexp.MustCompile(`(?m)^\s*$\n`)
	text = re.ReplaceAllString(text, "")
	o.outFunc = append(o.outFunc, text)
}

var importTemplate = `package %s

// Code generated by ast-tools. DO NOT EDIT unless you know what will happen

import (
%s
)

`

// todo
// gofmt -s -w
func (o *outputer) toString(dir string) string {
	imports := make([]string, 0, len(o.imports))
	for _, path := range o.imports {
		s := "    "
		if path.alias != "" && !strings.HasSuffix(path.path, "/"+path.alias+"\"") {
			s = s + path.alias + " " + path.path
		} else {
			s = s + path.path
		}
		imports = append(imports, s)
	}

	imports = append(imports, "    \"fmt\"")

	sort.Strings(imports)

	return fmt.Sprintf(importTemplate, path.Base(dir), strings.Join(imports, "\n")) + strings.Join(o.data, "") + strings.Join(o.outFunc, "")
}
